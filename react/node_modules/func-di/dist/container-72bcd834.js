const e=e=>e,t=e,s=e,n=(e,n,r,o)=>t({type:"di-injectable",token:e,dependencies:t(s(n)),factory:r,disposer:o}),r=(e,t,s)=>n(e,{},t,s),o=(e,t,s)=>n(e,{c:d},(({c:e})=>t.call(e,e)),s),a=(...e)=>{const[s,n]=e,r=1===e.length?{}:{default:n},a={type:"di-token",key:Symbol(s),...r,implementAs:(e,t)=>o(a,e,t)};return t(a)},c=e=>e.key.description,i=(e,s)=>t({type:"di-impl",token:e,impl:s}),d=a("container"),l=(e,n)=>t({type:"di-consumer",dependencies:t(s(e)),factory:n}),f=e=>l({c:d},(({c:t})=>e(t)));var u;!function(e){e.Stateful="stateful",e.Stateless="stateless"}(u||(u={}));const p=(e,s=u.Stateful)=>t({type:"di-provider",solution:e,strategy:s}),y=t({stateful:e=>p(e,u.Stateful),stateless:e=>p(e,u.Stateless)}),k=e=>new Map(e),h=(e,t,s)=>{for(const n of e){const{solution:e}=n,{token:r}=e;if(t.has(r.key)&&!s)throw new Error(`Token ${c(r)} already registered.`);t.set(r.key,n)}return t},w=e=>h(e??[],new Map),m=(e,s,n)=>{(e=>{const t=new Set,s=new Set,n=[],r=({solution:o})=>{const a=o.token,{key:i}=a;if(!t.has(i)){if(n.push(a),s.has(i))throw new Error(`Circular dependency detected: ${n.map((e=>`[${c(e)}]`)).join(" -> ")}`);if("di-injectable"===o.type){s.add(i);const t=o.dependencies;for(const{key:s}of Object.values(t)){const t=e.get(s);t&&r(t)}s.delete(i)}n.pop(),t.add(i)}};for(const t of e.values())s.clear(),r(t)})(e);const r=new Set,o=e=>r.delete(e),a=new Map,i=t=>{if(t.key===d.key)return g;const n=e.get(t.key);if(!n){if(s)try{return s.request(t)}catch{}if(Reflect.has(t,"default"))return t.default;throw new Error(`Cannot find provider for ${c(t)}`)}const{solution:r,strategy:o}=n;if(o===u.Stateful&&a.has(t.key))return a.get(t.key);if("di-impl"===r.type)return r.impl;const{dependencies:i,factory:p}=r,y=f(l(i,p));return o===u.Stateful&&a.set(r.token.key,y),y},f=e=>{const{dependencies:s,factory:n}=e,r=t(Object.fromEntries(Object.entries(s).map((([e,t])=>[e,i(t)]))));return n.call(r,r)},p=()=>{for(const[,t]of e){const{solution:e,strategy:s}=t;if("di-injectable"===e.type&&s===u.Stateful){const{token:{key:t},disposer:s}=e;if(a.has(t))try{s?.call(void 0,a.get(t)),a.delete(t)}catch(e){console.error(e)}}}};let y=!1;const S=e=>(...t)=>{if(y)throw new Error("The container has been disposed.");return e(...t)},g={register:S((t=>{const n=k(e);return h(t,n),m(n,s,o)})),override:S((t=>{const n=k(e);return h(t,n,!0),m(n,s,o)})),fork:S((e=>{return t=m(w(e),g,o),r.add(t),t;var t})),request:S(i),consume:S(f),clear:S(p),dispose:S((()=>{p(),e.clear();for(const e of r)e.dispose();y=!0,n?.(g)}))};return t(g)},S=e=>m(w(e));export{u as R,d as _,l as a,r as b,s as c,f as d,y as e,t as f,S as g,o as h,n as i,c as j,i as k,p,a as t};
