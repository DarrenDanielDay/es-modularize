import { consumer } from "./consumer.js";
import { tokenName, __FUNC_DI_CONTAINER__ } from "./token.js";
import { freeze } from "./shared.js";
export var ResolveStrategy;
(function (ResolveStrategy) {
    /**
     * Create when requested, singleton in the container.
     */
    ResolveStrategy["Stateful"] = "stateful";
    /**
     * Always create new instance when requested.
     */
    ResolveStrategy["Stateless"] = "stateless";
})(ResolveStrategy || (ResolveStrategy = {}));
freeze(ResolveStrategy);
export const provider = (solution, strategy = ResolveStrategy.Stateful) => freeze({
    type: "di-provider",
    solution,
    strategy,
});
export const provide = freeze({
    stateful: (solution) => provider(solution, ResolveStrategy.Stateful),
    stateless: (solution) => provider(solution, ResolveStrategy.Stateless),
});
/**
 * @internal
 */
const cloneProviders = (providers) => new Map(providers);
/**
 * @internal
 */
const emptyProviers = () => new Map();
/**
 * @internal
 */
const registerProviders = (providers, keyedProviders, allowOverrides) => {
    for (const provider of providers) {
        const { solution } = provider;
        const { token } = solution;
        if (keyedProviders.has(token.key) && !allowOverrides) {
            throw new Error(`Token ${tokenName(token)} already registered.`);
        }
        keyedProviders.set(token.key, provider);
    }
    return keyedProviders;
};
/**
 * @internal
 */
const newProviders = (providers) => registerProviders(providers ?? [], emptyProviers());
/**
 * @internal
 */
const circularDepsCheck = (keyedProviders) => {
    const seen = new Set();
    const passing = new Set();
    const path = [];
    const dfs = ({ solution }) => {
        const token = solution.token;
        const { key } = token;
        if (seen.has(key)) {
            return;
        }
        path.push(token);
        if (passing.has(key)) {
            throw new Error(`Circular dependency detected: ${path.map((node) => `[${tokenName(node)}]`).join(" -> ")}`);
        }
        if (solution.type === "di-injectable") {
            passing.add(key);
            const dependencies = solution.dependencies;
            for (const { key: dependencyKey } of Object.values(dependencies)) {
                const dependencyProvider = keyedProviders.get(dependencyKey);
                if (dependencyProvider) {
                    dfs(dependencyProvider);
                }
            }
            passing.delete(key);
        }
        path.pop();
        seen.add(key);
    };
    for (const key of keyedProviders.values()) {
        passing.clear();
        dfs(key);
    }
};
/**
 * @internal
 */
const closure = (keyedProviders, parent, notifyDisposed) => {
    circularDepsCheck(keyedProviders);
    const register = (providers) => {
        const cloned = cloneProviders(keyedProviders);
        registerProviders(providers, cloned);
        return closure(cloned, parent, childCleaner);
    };
    const override = (providers) => {
        const cloned = cloneProviders(keyedProviders);
        registerProviders(providers, cloned, true);
        return closure(cloned, parent, childCleaner);
    };
    const children = new Set();
    const childCleaner = (child) => children.delete(child);
    const asChild = (ioc) => (children.add(ioc), ioc);
    const fork = (providers) => asChild(closure(newProviders(providers), containerInstance, childCleaner));
    const requestCache = new Map();
    const request = (token) => {
        if (token.key === __FUNC_DI_CONTAINER__.key) {
            // @ts-expect-error Dynamic Implementation
            return containerInstance;
        }
        // @ts-expect-error Not type safe, but ensured type safe in user code because of immutability.
        const provider = keyedProviders.get(token.key);
        if (!provider) {
            if (parent) {
                try {
                    return parent.request(token);
                }
                catch {
                    // noop
                }
            }
            if (Reflect.has(token, "default")) {
                return token.default;
            }
            throw new Error(`Cannot find provider for ${tokenName(token)}`);
        }
        const { solution, strategy } = provider;
        if (strategy === ResolveStrategy.Stateful) {
            if (requestCache.has(token.key)) {
                // @ts-expect-error Not type safe, but ensured type safe in user code because of immutability.
                return requestCache.get(token.key);
            }
        }
        if (solution.type === "di-impl") {
            return solution.impl;
        }
        const { dependencies, factory } = solution;
        const dependencyInstance = consume(consumer(dependencies, factory));
        if (strategy === ResolveStrategy.Stateful) {
            requestCache.set(solution.token.key, dependencyInstance);
        }
        return dependencyInstance;
    };
    const consume = (consumer) => {
        const { dependencies, factory } = consumer;
        const context = freeze(
        // @ts-expect-error Dynamic Implementation
        Object.fromEntries(Object.entries(dependencies).map(([name, dependency]) => [name, request(dependency)])));
        return factory.call(context, context);
    };
    const clear = () => {
        for (const [, provider] of keyedProviders) {
            const { solution, strategy } = provider;
            if (solution.type === "di-injectable" && strategy === ResolveStrategy.Stateful) {
                const { token: { key }, disposer, } = solution;
                if (requestCache.has(key)) {
                    try {
                        disposer?.call(void 0, requestCache.get(key));
                        requestCache.delete(key);
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
            }
        }
    };
    let disposed = false;
    const disposedChecked = (fn) => 
    // @ts-expect-error Dynamic Implementation
    (...args) => {
        if (disposed) {
            throw new Error("The container has been disposed.");
        }
        return fn(...args);
    };
    const dispose = () => {
        clear();
        keyedProviders.clear();
        for (const child of children) {
            child.dispose();
        }
        disposed = true;
        notifyDisposed?.(containerInstance);
    };
    const containerInstance = {
        register: disposedChecked(register),
        override: disposedChecked(override),
        fork: disposedChecked(fork),
        request: disposedChecked(request),
        consume: disposedChecked(consume),
        clear: disposedChecked(clear),
        dispose: disposedChecked(dispose),
    };
    return freeze(containerInstance);
};
export const container = (providers) => closure(newProviders(providers));
//# sourceMappingURL=container.js.map