import type { Injectable } from "./injectable.js";
import { type Consumer } from "./consumer.js";
import { type Implementation, type Token } from "./token.js";
export declare enum ResolveStrategy {
    /**
     * Create when requested, singleton in the container.
     */
    Stateful = "stateful",
    /**
     * Always create new instance when requested.
     */
    Stateless = "stateless"
}
/**
 * Typed depencencies as `any` for contravariance.
 */
interface GeneralConsumer<R = unknown> extends Consumer<any, R> {
}
/**
 * Typed depencencies as `any` for contravariance.
 */
interface GeneralInjectable<T = unknown> extends Injectable<any, T> {
}
export interface IoCContainer {
    /**
     * Create a **NEW** container based on and the given providers.
     * No dynamic providers can be registered.
     * You must switch to a new container if you want to add any dependency providers.
     */
    readonly register: (this: void, providers: GeneralProvider[]) => IoCContainer;
    /**
     * Create a **NEW** container with providers overrides.
     * No dynamic providers can be registered.
     * You must switch to a new container if you want to add any dependency providers.
     */
    readonly override: (this: void, providers: GeneralProvider[]) => IoCContainer;
    /**
     * Create a child container with this container as parent.
     */
    readonly fork: (this: void, providers?: GeneralProvider[]) => IoCContainer;
    /**
     * Request a dependency from the container.
     */
    readonly request: <T extends unknown>(this: void, token: Token<T>) => T;
    /**
     * Request dependencies of a `Consumer` and return its instance.
     */
    readonly consume: <R extends unknown>(this: void, consumer: GeneralConsumer<R>) => R;
    /**
     * Clear the instance caches and invoke `disposer` for injectable if present.
     */
    readonly clear: (this: void) => void;
    /**
     * Dispose the container and release its resources.
     * When a container is disposed, it cannot handle dependency request any longer,
     * that is, invoke `clear()` and mark itself as `disposed`.
     */
    readonly dispose: (this: void) => void;
}
export declare type Solution<T> = Implementation<T> | GeneralInjectable<T>;
export declare type GeneralSolution = Solution<unknown>;
export interface Provider<T> {
    readonly type: "di-provider";
    readonly solution: Solution<T>;
    readonly strategy: ResolveStrategy;
}
/**
 * Typed depencencies as `any` for contravariance.
 */
export interface GeneralProvider extends Provider<any> {
}
export declare const provider: <T extends unknown>(solution: Solution<T>, strategy?: ResolveStrategy) => Provider<T>;
export declare const provide: {
    stateful: <T extends unknown>(solution: Solution<T>) => Provider<T>;
    stateless: <T_1 extends unknown>(solution: GeneralInjectable<T_1>) => Provider<T_1>;
};
export declare const container: (providers?: GeneralProvider[]) => IoCContainer;
export {};
//# sourceMappingURL=container.d.ts.map