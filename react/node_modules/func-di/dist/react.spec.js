/**
 * @jest-environment jsdom
 */
import "@testing-library/jest-dom";
import React from "react";
import PropTypes from "prop-types";
import { connectInjectionHooks, Inject, Provide, useContainer, useContainerRequest } from "./react.js";
import { provide } from "./container.js";
import { implementation, token } from "./token.js";
import { inject } from "./inject.js";
import { render, screen } from "@testing-library/react";
import { useInjection } from "./hooks.js";
const countService = token("count");
const rootCountImpl = implementation(countService, { count: 6 });
const messageService = token("message");
const msgImpl = inject({ countService }).implements(messageService, ({ countService }) => {
    return {
        renderMessage(tag) {
            return (React.createElement("div", null,
                React.createElement("span", null, tag),
                React.createElement("span", null, countService.count)));
        },
    };
});
const CountMessage = Inject({ countService, messageService })
    .props()
    .composed.fc(({ messageService, tag }) => messageService.renderMessage(tag));
describe("React higher ordered component", () => {
    it("should retrieve injected service instance", () => {
        const RootIoC = Provide([provide.stateful(rootCountImpl), provide.stateful(msgImpl)]).dependent();
        const App = () => (React.createElement(RootIoC, null,
            React.createElement(Father, null,
                React.createElement(Child, null))));
        const OverrideIoC = Provide([provide.stateful(implementation(countService, { count: 666 }))]).override();
        const Father = Inject({ cnt: countService })
            .props()
            .separated.fc(({ props: { children } }) => {
            return (React.createElement(React.Fragment, null,
                React.createElement(CountMessage, { tag: "father" }),
                React.createElement(OverrideIoC, null, children)));
        });
        const Child = () => {
            return React.createElement(CountMessage, { tag: "child" });
        };
        render(React.createElement(App, null));
        const father = screen.getByText("father");
        const child = screen.getByText("child");
        expect(father.nextSibling).toHaveTextContent(`6`);
        expect(child.nextSibling).toHaveTextContent(`666`);
    });
    it("should be used like this", () => {
        const ComposedFC = Inject({ countService })
            .props({
            propTypes: {
                foo: PropTypes.string.isRequired,
            },
        })
            .composed.fc.memo(({ countService, foo }) => {
            return (React.createElement("div", null,
                React.createElement("p", null,
                    React.createElement("span", null, foo),
                    React.createElement("span", null, countService.count))));
        });
        const SeparatedFC = Inject({ countService })
            .props()
            .separated.fc.memo(({ ctx, props }) => {
            return (React.createElement("div", null,
                React.createElement("p", null,
                    React.createElement("span", null, props.foo),
                    React.createElement("span", null, ctx.countService.count))));
        });
        const ComposedForwardRef = Inject({ countService })
            .props()
            .composed.forwardRef.memo(({ countService, foo }, ref) => {
            return (React.createElement("div", { ref: ref },
                React.createElement("p", null,
                    React.createElement("span", null, foo),
                    React.createElement("span", null, countService.count))));
        });
        const SeparatedForwardRef = Inject({ countService })
            .props()
            .separated.forwardRef.memo(({ ctx, props }, ref) => {
            return (React.createElement("div", { ref: ref },
                React.createElement("p", null,
                    React.createElement("span", null, props.foo),
                    React.createElement("span", null, ctx.countService.count))));
        });
        const RootProvider = Provide([provide.stateful(implementation(countService, { count: 0 }))]).fork();
        render(React.createElement(RootProvider, null,
            React.createElement(ComposedFC, { foo: "composed-fc" }),
            React.createElement(SeparatedFC, { foo: "separated-fc" }),
            React.createElement(ComposedForwardRef, { foo: "composed-forward-ref" }),
            React.createElement(SeparatedForwardRef, { foo: "separated-forward-ref" })));
        expect(screen.getByText("composed-fc").nextElementSibling).toHaveTextContent("0");
        expect(screen.getByText("separated-fc").nextElementSibling).toHaveTextContent("0");
        expect(screen.getByText("composed-forward-ref").nextElementSibling).toHaveTextContent("0");
        expect(screen.getByText("separated-forward-ref").nextElementSibling).toHaveTextContent("0");
    });
});
describe("React hooks", () => {
    describe("connectInjectionHooks", () => {
        it("should connect `useInjection` hooks", () => {
            const Component = ({ foo }) => {
                const { count } = useInjection(countService);
                return (React.createElement("div", null,
                    React.createElement("p", null,
                        React.createElement("span", null, "prop"),
                        React.createElement("span", null, foo)),
                    React.createElement("p", null,
                        React.createElement("span", null, "injection"),
                        React.createElement("span", null, count))));
            };
            const ConnectedComponent = connectInjectionHooks(Component);
            const RootProvider = Provide([provide.stateful(rootCountImpl)]).override();
            render(React.createElement(RootProvider, null,
                React.createElement(ConnectedComponent, { foo: 666 })));
            expect(screen.getByText("prop").nextElementSibling).toHaveTextContent("666");
            expect(screen.getByText("injection").nextElementSibling).toHaveTextContent("6");
        });
        it("should preserve `displayName` and other info", () => {
            const Component = () => null;
            Component.displayName = "Component";
            Component.propTypes = {};
            const connected = connectInjectionHooks(Component);
            expect(connected.propTypes).toStrictEqual({});
            expect(connected.displayName).toBe("Component");
        });
    });
    describe("useContainer", () => {
        it("should return container", () => {
            const Component = () => {
                const c = useContainer();
                expect(typeof c.request).toBe("function");
                return null;
            };
            render(React.createElement(Component, null));
        });
    });
    describe("useContainerRequest", () => {
        it("should request dependency", () => {
            const Component = () => {
                const c = useContainerRequest(countService);
                expect(c).toStrictEqual({ count: 6 });
                return null;
            };
            const RootProvider = Provide([provide.stateful(rootCountImpl)]).override();
            render(React.createElement(RootProvider, null,
                React.createElement(Component, null)));
        });
    });
});
//# sourceMappingURL=react.spec.js.map